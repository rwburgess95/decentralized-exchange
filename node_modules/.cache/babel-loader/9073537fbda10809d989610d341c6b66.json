{"ast":null,"code":"import _objectSpread from \"/Users/raymondburgess/Dapps/blockchain-developer-bootcamp-v2/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread2\";\nimport { get, groupBy, reject } from 'lodash';\nimport { createSelector } from 'reselect';\nimport moment from 'moment';\nimport { ETHER_ADDRESS, GREEN, RED, tokens, ether } from '../helpers';\n\nvar account = function account(state) {\n  return get(state, 'web3.account');\n};\n\nexport var accountSelector = createSelector(account, function (a) {\n  return a;\n});\n\nvar tokenLoaded = function tokenLoaded(state) {\n  return get(state, 'token.loaded', false);\n};\n\nexport var tokenLoadedSelector = createSelector(tokenLoaded, function (tl) {\n  return tl;\n});\n\nvar exchangeLoaded = function exchangeLoaded(state) {\n  return get(state, 'exchange.loaded', false);\n};\n\nexport var exchangeLoadedSelector = createSelector(exchangeLoaded, function (el) {\n  return el;\n});\n\nvar exchange = function exchange(state) {\n  return get(state, 'exchange.connection');\n};\n\nexport var exchangeSelector = createSelector(exchange, function (e) {\n  return e;\n});\nexport var contractsLoadedSelector = createSelector(tokenLoaded, exchangeLoaded, function (tl, el) {\n  return tl && el;\n}); // All Orders\n// const allOrdersLoaded = state => get(state, 'exchange.allOrders.loaded', false)\n// const allOrders = state => get(state, 'exchange.allOrders.data', [])\n// console.log(\"Does this ever execute?\")\n// // Cancelled orders\n// const cancelledOrdersLoaded = state => get(state, 'exchange.cancelledOrders.loaded', false)\n// export const cancelledOrdersLoadedSelector = createSelector(cancelledOrdersLoaded, loaded => loaded)\n// const cancelledOrders = state => get(state, 'exchange.cancelledOrders.data', [])\n// export const cancelledOrdersSelector = createSelector(cancelledOrders, o => o)\n// Filled Orders\n\nvar filledOrdersLoaded = function filledOrdersLoaded(state) {\n  return get(state, 'exchange.filledOrders.loaded', false);\n};\n\nexport var filledOrdersLoadedSelector = createSelector(filledOrdersLoaded, function (loaded) {\n  return loaded;\n});\n\nvar filledOrders = function filledOrders(state) {\n  return get(state, 'exchange.filledOrders.data', []);\n};\n\nexport var filledOrdersSelector = createSelector(filledOrders, function (orders) {\n  // Sort orders by date ascending for price comparison\n  orders = orders.sort(function (a, b) {\n    return a.timestamp - b.timestamp;\n  }); // Decorate the orders\n\n  orders = decorateFilledOrders(orders); // Sort orders by date descending for display\n\n  orders = orders.sort(function (a, b) {\n    return b.timestamp - a.timestamp;\n  });\n  return orders;\n});\n\nvar decorateFilledOrders = function decorateFilledOrders(orders) {\n  // Track previous order to compare history\n  var previousOrder = orders[0];\n  return orders.map(function (order) {\n    order = decorateOrder(order);\n    order = decorateFilledOrder(order, previousOrder);\n    previousOrder = order; // Update the previous order once it's decorated\n\n    return order;\n  });\n};\n\nvar decorateOrder = function decorateOrder(order) {\n  var etherAmount;\n  var tokenAmount;\n\n  if (order.tokenGive == ETHER_ADDRESS) {\n    etherAmount = order.amountGive;\n    tokenAmount = order.amountGet;\n  } else {\n    etherAmount = order.amountGet;\n    tokenAmount = order.amountGive;\n  } // Calculate token price to 5 decimal places\n\n\n  var precision = 100000;\n  var tokenPrice = etherAmount / tokenAmount;\n  tokenPrice = Math.round(tokenPrice * precision) / precision;\n  return _objectSpread(_objectSpread({}, order), {}, {\n    etherAmount: ether(etherAmount),\n    tokenAmount: tokens(tokenAmount),\n    tokenPrice: tokenPrice,\n    formattedTimestamp: moment.unix(order.timestamp).format('h:mm:ss a M/D')\n  });\n};\n\nvar decorateFilledOrder = function decorateFilledOrder(order, previousOrder) {\n  return _objectSpread(_objectSpread({}, order), {}, {\n    tokenPriceClass: tokenPriceClass(order.tokenPrice, order.id, previousOrder)\n  });\n};\n\nvar tokenPriceClass = function tokenPriceClass(tokenPrice, orderId, previousOrder) {\n  // Show green price if only one order exists\n  if (previousOrder.id === orderId) {\n    return GREEN;\n  } // Show green price if order price higher than previous order\n  // Show red price if order price lower than previous order\n\n\n  if (previousOrder.tokenPrice <= tokenPrice) {\n    return GREEN; // success\n  } else {\n      return RED; // danger\n    }\n}; // const openOrders = state => {\n//   const all = allOrders(state)\n//   const filled = filledOrders(state)\n//   const cancelled = cancelledOrders(state)\n//   return all\n//   const openOrders = reject(all, (order) => {\n//     const orderFilled = filled.some((o) => o.id === order.id)\n//     const orderCancelled = cancelled.some((o) => o.id === order.id)\n//     return(orderFilled || orderCancelled)\n//   })\n//   return openOrders\n// }\n// const orderBookLoaded = state => filledOrdersLoaded(state)//cancelledOrdersLoaded(state) && filledOrdersLoaded(state) && allOrdersLoaded(state)\n// export const orderBookLoadedSelector = createSelector(orderBookLoaded, loaded => loaded)\n// // Create the order book\n// export const orderBookSelector = createSelector(\n//   openOrders,\n//   (orders) => {\n//     // Decorate orders\n//     orders = decorateOrderBookOrders(orders)\n//     // Group orders by \"orderType\"\n//     orders = groupBy(orders, 'orderType')\n//     // Fetch buy orders\n//     const buyOrders = get(orders, 'buy', [])\n//     // Sort buy orders by token price\n//     orders = {\n//       ...orders,\n//       buyOrders: buyOrders.sort((a,b) => b.tokenPrice - a.tokenPrice)\n//     }\n//     // Fetch sell orders\n//     const sellOrders = get(orders, 'sell', [])\n//     // Sort sell orders by token price\n//     orders = {\n//       ...orders,\n//       sellOrders: sellOrders.sort((a,b) => b.tokenPrice - a.tokenPrice)\n//     }\n//     return orders\n//   }\n// )\n// const decorateOrderBookOrders = (orders) => {\n//   return(\n//     orders.map((order) => {\n//       order = decorateOrder(order)\n//       order = decorateOrderBookOrder(order)\n//       return(order)\n//     })\n//   )\n// }\n// const decorateOrderBookOrder = (order) => {\n//   const orderType = order.tokenGive === ETHER_ADDRESS ? 'buy' : 'sell'\n//   return({\n//     ...order,\n//     orderType,\n//     orderTypeClass: (orderType === 'buy' ? GREEN : RED),\n//     orerFillClass: orderType === 'buy' ? 'sell' : 'buy'\n//   })\n// }","map":{"version":3,"sources":["/Users/raymondburgess/Dapps/blockchain-developer-bootcamp-v2/src/store/selectors.js"],"names":["get","groupBy","reject","createSelector","moment","ETHER_ADDRESS","GREEN","RED","tokens","ether","account","state","accountSelector","a","tokenLoaded","tokenLoadedSelector","tl","exchangeLoaded","exchangeLoadedSelector","el","exchange","exchangeSelector","e","contractsLoadedSelector","filledOrdersLoaded","filledOrdersLoadedSelector","loaded","filledOrders","filledOrdersSelector","orders","sort","b","timestamp","decorateFilledOrders","previousOrder","map","order","decorateOrder","decorateFilledOrder","etherAmount","tokenAmount","tokenGive","amountGive","amountGet","precision","tokenPrice","Math","round","formattedTimestamp","unix","format","tokenPriceClass","id","orderId"],"mappings":"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","sourcesContent":["import { get, groupBy, reject } from 'lodash'\nimport { createSelector } from 'reselect'\nimport moment from 'moment'\nimport { ETHER_ADDRESS, GREEN, RED, tokens, ether } from '../helpers'\n\nconst account = state => get(state, 'web3.account')\nexport const accountSelector = createSelector(account, a => a)\n\nconst tokenLoaded = state => get(state, 'token.loaded', false)\nexport const tokenLoadedSelector = createSelector(tokenLoaded, tl => tl)\n\nconst exchangeLoaded = state => get(state, 'exchange.loaded', false)\nexport const exchangeLoadedSelector = createSelector(exchangeLoaded, el => el)\n\nconst exchange = state => get(state, 'exchange.connection')\nexport const exchangeSelector = createSelector(exchange, e => e)\n\nexport const contractsLoadedSelector = createSelector(\n  tokenLoaded,\n  exchangeLoaded,\n  (tl, el) => (tl && el)\n)\n\n// All Orders\n// const allOrdersLoaded = state => get(state, 'exchange.allOrders.loaded', false)\n// const allOrders = state => get(state, 'exchange.allOrders.data', [])\n// console.log(\"Does this ever execute?\")\n\n// // Cancelled orders\n// const cancelledOrdersLoaded = state => get(state, 'exchange.cancelledOrders.loaded', false)\n// export const cancelledOrdersLoadedSelector = createSelector(cancelledOrdersLoaded, loaded => loaded)\n\n// const cancelledOrders = state => get(state, 'exchange.cancelledOrders.data', [])\n// export const cancelledOrdersSelector = createSelector(cancelledOrders, o => o)\n\n// Filled Orders\nconst filledOrdersLoaded = state => get(state, 'exchange.filledOrders.loaded', false)\nexport const filledOrdersLoadedSelector = createSelector(filledOrdersLoaded, loaded => loaded)\n\nconst filledOrders = state => get(state, 'exchange.filledOrders.data', [])\nexport const filledOrdersSelector = createSelector(\n  filledOrders,\n  (orders) => {\n    // Sort orders by date ascending for price comparison\n    orders = orders.sort((a,b) => a.timestamp - b.timestamp)\n    // Decorate the orders\n    orders = decorateFilledOrders(orders)\n    // Sort orders by date descending for display\n    orders = orders.sort((a,b) => b.timestamp - a.timestamp)\n    return orders\n  }\n)\n\nconst decorateFilledOrders = (orders) => {\n  // Track previous order to compare history\n  let previousOrder = orders[0]\n  return(\n    orders.map((order) => {\n      order = decorateOrder(order)\n      order = decorateFilledOrder(order, previousOrder)\n      previousOrder = order // Update the previous order once it's decorated\n      return order\n    })\n  )\n}\n\nconst decorateOrder = (order) => {\n  let etherAmount\n  let tokenAmount\n\n  if(order.tokenGive == ETHER_ADDRESS) {\n    etherAmount = order.amountGive\n    tokenAmount = order.amountGet\n  } else {\n    etherAmount = order.amountGet\n    tokenAmount = order.amountGive\n  }\n\n  // Calculate token price to 5 decimal places\n  const precision = 100000\n  let tokenPrice = (etherAmount / tokenAmount)\n  tokenPrice = Math.round(tokenPrice * precision) / precision\n\n  return({\n    ...order,\n    etherAmount: ether(etherAmount),\n    tokenAmount: tokens(tokenAmount),\n    tokenPrice,\n    formattedTimestamp: moment.unix(order.timestamp).format('h:mm:ss a M/D')\n  })\n}\n\nconst decorateFilledOrder = (order, previousOrder) => {\n  return({\n    ...order,\n    tokenPriceClass: tokenPriceClass(order.tokenPrice, order.id, previousOrder)\n  })\n}\n\nconst tokenPriceClass = (tokenPrice, orderId, previousOrder) => {\n  // Show green price if only one order exists\n  if(previousOrder.id === orderId) {\n    return GREEN\n  }\n\n  // Show green price if order price higher than previous order\n  // Show red price if order price lower than previous order\n  if(previousOrder.tokenPrice <= tokenPrice) {\n    return GREEN // success\n  } else {\n    return RED // danger\n  }\n}\n\n// const openOrders = state => {\n//   const all = allOrders(state)\n//   const filled = filledOrders(state)\n//   const cancelled = cancelledOrders(state)\n\n//   return all\n//   const openOrders = reject(all, (order) => {\n//     const orderFilled = filled.some((o) => o.id === order.id)\n//     const orderCancelled = cancelled.some((o) => o.id === order.id)\n//     return(orderFilled || orderCancelled)\n//   })\n\n//   return openOrders\n// }\n\n// const orderBookLoaded = state => filledOrdersLoaded(state)//cancelledOrdersLoaded(state) && filledOrdersLoaded(state) && allOrdersLoaded(state)\n// export const orderBookLoadedSelector = createSelector(orderBookLoaded, loaded => loaded)\n\n// // Create the order book\n// export const orderBookSelector = createSelector(\n//   openOrders,\n//   (orders) => {\n//     // Decorate orders\n//     orders = decorateOrderBookOrders(orders)\n//     // Group orders by \"orderType\"\n//     orders = groupBy(orders, 'orderType')\n//     // Fetch buy orders\n//     const buyOrders = get(orders, 'buy', [])\n//     // Sort buy orders by token price\n//     orders = {\n//       ...orders,\n//       buyOrders: buyOrders.sort((a,b) => b.tokenPrice - a.tokenPrice)\n//     }\n//     // Fetch sell orders\n//     const sellOrders = get(orders, 'sell', [])\n//     // Sort sell orders by token price\n//     orders = {\n//       ...orders,\n//       sellOrders: sellOrders.sort((a,b) => b.tokenPrice - a.tokenPrice)\n//     }\n//     return orders\n//   }\n// )\n\n// const decorateOrderBookOrders = (orders) => {\n//   return(\n//     orders.map((order) => {\n//       order = decorateOrder(order)\n//       order = decorateOrderBookOrder(order)\n//       return(order)\n//     })\n//   )\n// }\n\n// const decorateOrderBookOrder = (order) => {\n//   const orderType = order.tokenGive === ETHER_ADDRESS ? 'buy' : 'sell'\n//   return({\n//     ...order,\n//     orderType,\n//     orderTypeClass: (orderType === 'buy' ? GREEN : RED),\n//     orerFillClass: orderType === 'buy' ? 'sell' : 'buy'\n//   })\n// }\n"]},"metadata":{},"sourceType":"module"}